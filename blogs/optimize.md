# Optimization

优化，是一个比较大，比较严肃，要求功底比较深的话题。我们将要讨论的仅仅是几个简单优化

下面首先给出优化的主要分类

+ 前端优化 (局部的，流不敏感的)
  + 常量折叠
  + 代数优化
  + 不可达代码删除
+ 中期优化 (全局的，流敏感的)
  + 常量传播
  + 拷贝传播
  + 死代码删除
  + 公共子表达式删除
+ 后期优化 (汇编代码级进行)
  + 寄存器分配
  + 指令调度
  + 窥孔优化

此外有一点，我们将删除声明未使用变量，停止为其在本地变量表分配空间，在我们这个编译器里将之作为“优化”对待。

## Delete Unused Variables

删除声明未使用变量，实质来说，这个算不得什么了不得的“优化”，这么做目前能看到的唯一的收益就是节省了本地变量表的空间。

总体实现思路是通过上下文分析，扫描该变量的使用情况，对于声明了但是没有使用的本地变量，那么就删除该声明语句。并且在该过程中给出警告。

此外应当注意一点，我们也扫描了方法的参数使用情况，但是我们并没有将未使用的方法参数删除之。因为我们没有去分析该方法的调用情况，一旦此处删除了，那么可能导致后期方法调用失败。因此，对于方法参数未使用情况，我们仅仅是给出了警告。

但是应当注意如下情况。

```java
int Compute(int num, boolean state)
{
    int x;
    int total;
    total = num * 10;
    return 1;
}
```

对于以上所述的这个方法，我们目前能做到的是，删除`int x`语句，对`boolean state`声明给出警告。其实很显然，对于`total`的声明，以及下面的赋值，是能执行的，也是没错误的，但是对于整个方法来说，是没有任何意义的，因此`num`的存在也是没有意义的。
关于这个问题的讨论，我们将在下方“死代码删除”进行。

## Constant Folding

常量折叠，基本思想是：在编译期计算常量表达式的值。

例如：对于`a=3+5; b=false&&true;`，其实我们没有必要将这种表达式放到运行时求值，编译时就可以求值，然后使程序暴露更多的优化机会。比如不可达代码删除等。

基本的实现似乎是对于每个语句进行考察，对表达是部分尝试进行求值，能求值便求值，不能求值便放弃掉。

应该注意，此处我们并没有对于`b=a+3-4;`进行求值，因为这里涉及到了语义考察，应当仔细思考之后再完善。

还有一点，对于可能造成溢出的式子，我们的求值行为应当慎重进行。

## Scalar Replacement of Aggregates

