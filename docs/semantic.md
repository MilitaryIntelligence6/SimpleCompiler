# Semantic

语义分析器工作于语法分析器输出的抽象语法树，通过对该语法树的分析回答一个问题：源程序是否符合语义规则。如果确实存在问题，那么这个程序必定不合法，必定会运行失败，因此后期的步骤也就没必要继续。但是在此阶段要给出尽可能准确的报错信息，供用户参考并修改源代码。语义分析中最重要的工作便是类型检查，此外还会有一些其他的检查，例如变量是否声明等。

## 语义分析实现

### 符号表

语义分析的正常进行强烈依赖符号表。所谓符号，程序中的变量、方法、字段、类都是符号。符号表存储了程序中的符号的相关信息，这些信息包括类型、作用域、访问控制信息等等，而且符号表必须非常搞笑，因为程序中符号的规模会非常大。

为保证高效，采用了哈希表来存储符号及其相关信息，以符号名字为键，以符号的相关信息为值，建立映射。按照树形结构，组织各个作用域的符号及信息，建立全局符号表。

全局符号表的大致结构如下：

// TODO: 插入树形图

+ ClassTable
  + ClassBinding
    + BaseClass
    + FieldTable
      + Field
      + ...
    + MethodTable
      + Method
      + ...
  + ...

+ MethodVariableTable

+ ClassTable

  全局符号表的入口，直接维护了类名和类的相关信息的

+ ClassBinding

  存储了类的相关信息，包括父类，字段表，方法表。其中字段表和方法表是以名为键的映射。

+ Field

  存储了字段的声明类型

+ Method

  存储了方法的相关信息，包括声明的返回类型，参数的个数及各自类型。

+ MethodVariableTable

  参数和本地变量表，是名字和类型的映射。当分析某个方法的时候，对于该方法的参数和本地变量的访问是相当频繁的，因此将他们单独存储到某个位置，分析完毕即销毁，优化空间的占用。

### 分析思路

本质上说，所谓“分析”仅仅是语法树的遍历而已，只是附带上了附加条件，要求某子树符合某个要求。此外我们应当注意到，类型的声明、字段的声明和方法的声明，并没有任何值得语义分析的地方，真正值得我们去分析和检查的是语句和表达式，查看它们是否合法。因此，分析过程可简要分成两步。

1. 信息收集和索引

    对当前语法树的前几层进行遍历，扫描并存储类信息，各自的字段和方法相关信息，构建全局随时可用的“全局符号表”，该过程仅在语义分析实际进行之前进行一次。

2. 语义分析和检查

    收集要分析的方法的参数和变量信息，然后顺序遍历方法的每一条语句和表达式。如果找到错误，那么就输出一条信息，提示用户在某位置发现何种类型的错误，并尽可能进行恢复，继续检查下文，在一趟分析中给出尽可能多的错误信息。

对于每个方法，都执行一遍步骤2，直到所有的方法都分析过。如果未发现任何错误，那么进入下一阶段，如果发现问题，那么在给出所有信息后，退出编译过程。

## 分析过程

### 类型检查

类型检查是语义分析的重点所在，如果此处的检查没有通过，那么这个程序必定存在问题，必定不能运行。下面通过几个例子来展示类型检查的工作细节。

#### 表达式

对于表达式而言，类型检查主要分为以下几类

+ 操作符

    本源程序语言支持一个一元操作符 `!`，五个二元操作符 `+`/`-`/`*`/`&&`/`<`

    对这种类型的表达式，类型检查的步骤是：先确认两侧/单侧的表达式类型，然后确认两侧表达式类型是否匹配，最后确认当前的操作符能否对该类型进行操作。全部没有问题的话，才认为该表达式通过了检查，并确认该表达式的值类型。

    例如：

  + `10 + true`

    很显然两侧类型不匹配，类型检查的给出的信息是

    `Error: Line 1 Add expression: the type of left is @int, but the type of right is @boolean`

  + `true < false`

    两侧类型是一致的，但很显然，这个比较没有任何意义，因此这个表达式也是个错误

    `Error: Line 1 only integer numbers can be compared.`

  + `!200`

    只有布尔值才能取非，因此这个表达式显然也是非法的。

    `Error: Line 1 the exp cannot calculate to a boolean.`

+ 方法调用

    本程序语言仅支持实例方法调用，不支持静态方法、方法重载等。

    对于方法调用表达式，类型检查主要关注形参及实参。首先确认形参和实参数量是相等的，然后确认参数的类型是一一对应的。通过检查后，表达式的值类型被设定成为该方法的返回值类型。

    假定有方法 `int Compute(int a, int b)`，对它的两种错误调用如下

  + `this.Compute(10)`

    很明显，这并不能通过第一步：对于参数个数的检查。

    `Error: Line 1 the count of arguments is not match.`

  + `this.Compute(10, false)`

    显然，第二个参数的类型不是匹配的。

    `Error: Line 32 the parameter 2 needs a int, but got a boolean`

  + <a id="printexp">`print(exp)`</a>

    应当注意到，在本程序中我们认为print是一个语句，而不是函数调用表达式。这样做的目的是为了简化该编译器开发，但其本质依旧是函数调用，因此对于它的类型检查等同函数调用。此外，本程序仅支持每行输出一个整型数字，因此exp最终应当能求得一个整型数字。

+ 返回表达式

    这里是确认方法声明处的返回类型和实际的返回类型是匹配的。首先检查 `return` 关键字后紧跟的表达式是否有意义，然后再确认这个有意义的表达式是否符合返回类型。考虑这样的一个源程序：

    ```java
    boolean DoSomething(int num)
    {
        // Some VarDecls
        // Some Statements
        return 10;
    }
    ```

    很明显，实际返回类型和声明的返回类型不一致，我们应当给出相应的错误提示。

    `Error: Line 3 the return expression's type is not match the method "DoSomething" declared.`

+ 标识符 / 字面量 / `this` / `new id()`

    这里是讨论剩余的几类特殊的表达式，变量/字段引用，字面量，this关键字，实例化对象表达式。

  + <a id="identifier">标识符</a>

    查找标识符大致分为两步，首先在参数列表/本地变量表查找该标识符，若查找失败，再去类/基类字段声明列表中尝试查找。若最终查找失败，则报告一个错误。

    `Error: Line 1 you should declare "x" before use it.`

  + 字面量 / `this`

    这个种类主要包括整型数字，`true`/`false`/`this`关键字。应当特别注意`this`关键字，它指代当前类的实例，它的类型自然是该关键字所处的类的类型。

  + <a id="classnotfound">`new id()`</a>

    应当注意到本程序不支持构造函数，因此每个类只有一个形式上的无参构造器。除主类外，对于其他普通类的声明顺序不做要求。如果尝试实例化一个不存在的类，也会报告错误。

        `Error: Line 1 cannot find the declaration of class "XXX".`

#### 语句

有了前面表达式级的类型检查作为基础，做语句的类型检查就很方便快捷了。

+ `print`

    [上文](#printexp)已给出解释

+ `if` / `while`

    对于这种类型的语句，只需要检查是否符合对应的规则即可。例如条件判断处必须是个布尔类型的表达式

+ `{StatementList}`

    这种类型的表达式，按顺序轮流进行检查即可

+ `id = exp;`

    赋值语句，只要等号两侧的类型是互相匹配的，那就允许赋值。

### 特别注意

应当注意到，我们之前提到的一直是“类型匹配”，而不是“类型相等”。隐含的，我们允许合法的类型隐式转换。

### 其他检查

在本程序里，我们还做了另外两个对于标识符的检查：[变量/字段标识符](#identifier)，[类名标识符](#classnotfound)。由于这两类标识符存在于不同的符号表里面，因此本程序可以声明类似 `Class Class;` 这样类型和名称一样的变量/字段，这种声明是合法的，在使用时具体的意义取决于这个符号所在位置的语义。

### 错误恢复

前面已经提到，在这个阶段，我们要在一遍扫描中给出尽可能多的信息，因此我们需要实现错误恢复功能。出现的具体错误和恢复思想如下。

+ 使用了未声明的变量

    一旦发现某处使用了未使用的变量，那么会立即给出信息提示此处发现一个未声明变量，但是分析还是要继续，于是原地定义该变量是一个 `unkonwn` 类型，使用该类型，进行接下来的分析。

+ 操作符型表达式

    例如 `true + 10`，`!200`这种类型的错误，我们优先考虑操作符的语义，例如在我们的程序中，加减乘必定得出一个整数，比较运算必定得出布尔类型的值。我们就按照该操作符该有的语义得出结果，然后进行下面的分析。

+ 方法调用

    方法调用出现了问题，例如参数不全、参数类型不匹配，我们给出应当提示用户的信息之后，继续按照方法该有的返回值进行下面的分析。