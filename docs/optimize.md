# Optimization

代码优化是对被优化的程序进行的语义保持的变换。所谓语义保持，是指程序的可观测行为保持不变。但变换的目的是让程序能够比以前更小、更快、更节能等等。但我们应当也意识到，这个世界上不存在“完全优化”的程序。

但代码优化也是很困难的，因为不能保证优化总能产生“好”的结果，此外优化的顺序和组合很关键，很多优化问题是非确定的，优化的正确性论证很微妙。

下面首先给出优化的主要分类和类型

+ 前端优化 (局部的，流不敏感的)
  + 常量折叠
  + 代数化简
  + 不可达代码删除
+ 中期优化 (全局的，流敏感的)
  + 常量传播
  + 拷贝传播
  + 死代码删除
  + 公共子表达式删除
+ 后期优化 (汇编代码级进行)
  + 寄存器分配
  + 指令调度
  + 窥孔优化

在本程序中，我们只在抽象语法树层面做些简单的优化，常量折叠和不可达代码删除。此外，我们将删除声明未使用变量，停止为其在本地变量表分配空间，这一行为放在优化阶段。

## 常量折叠

简言之，常量折叠就是在编译期计算常量表达式的值。

例如：对于 `a=3+5; b=false&&true;` ，这种类型的表达式没有必要让它在运行时求值，因为编译时就可以完成了。基于已经求得的值，可以使程序暴露更多的优化机会，比如不可达代码删除等。

基本的实现思路是对于考察每个语句的表达式部分，尝试对其运算，若能够求值，便用求得的结果替换掉原表达式。

如上例，进行常量折叠优化后的代码就变成了 `a=8; b = false;`。

## 不可达代码删除

顾名思义，此优化是指删除掉“永远不会到达”的代码。若某部分代码“不可达”，那么就永远不会执行到这部分，因此删除掉该部分是安全的。

举例如下：

```java
if (true) {
  // branch 1
  a = b + 10;
} else {
  // branch 2
  b = a + 10;
}

while (false) {
  a = a + 1;
}
```

对于以上一段代码，很显然，分支2和循环体内的代码永远不会执行到，因此我们可以将其删除，而且不会带来任何副作用，这种做法是安全的。因此优化后的结果就变成了

```java
// branch1
a = b + 10;
```

## 消除未用变量

删除声明未使用变量，实质来说，这个算不得什么了不得的“优化”，这么做目前能看到的唯一的收益就是节省了本地变量表的空间。

总体实现思路是通过上下文分析，扫描该变量的使用情况，对于声明了但是没有使用的本地变量，那么就删除该声明语句。并且在该过程中给出警告。

此外应当注意一点，我们也扫描了方法的参数使用情况，但是我们并没有将未使用的方法参数删除之。因为我们没有去分析该方法的调用情况，一旦此处删除了，那么可能导致后期方法调用失败。因此，对于方法参数未使用情况，我们仅仅是给出了警告。

但是应当注意如下情况。

```java
int Compute(int num, boolean state)
{
    int x;
    int total;
    total = num * 10;
    return total;
}
```

对于以上所述的这段代码，我们目前的做法是，删除`int x`，对`boolean state`声明给出警告。其实很显然，对于`total`的声明，以及下面的赋值，是能执行的，也是没错误的，但是对于整个方法来说，是没有任何意义的，因此`num`的存在也是没有意义的。